{"pages":[{"title":"404","text":"","path":"404/index.html","date":"12-18","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"12-18","excerpt":""}],"posts":[{"title":"Analysis","text":"前端要点知识总结vue实现数据双向绑定的原理 vue实现数据双向绑定主要是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。具体话其实就是通过Obeject.defineProperty() 中的setter和getter来监听属性变动实现Observer进行数据的监听然后就是通知订阅者，那么订阅者其实就是简单的一个数组，这个数组中的内容就是我门使用了的一个数据的集合，使用了的数据可以通过getter得到，其实就是在调用的时候给数组里面添加一个订阅者这样就是实现了一个Watcher（需要监听的数据的集合），然后在实现一个Compile其作用就是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，其实vue的数据双向绑定就是MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 Vue和SEO？ vue主要一个开发框架，通过vue－router可以实现单页应用的开发，但是单页应用本身就对seo不友好，现在vue官方给出的解决方案是vue-server-renderer服务端渲染，但是我觉得对于一个真正适合做成单页应用的项目的话，seo其实是可以不用考虑的，反正项目本身是需要登录才能进入的，但是像其他一些类似于商城的项目的话，我们可以吧项目分开，像单个的详情页我们没有必要放到单页路由中，可以把她们分出去，毕竟对于商城来说商品才是详情才是需要seo优化的。或者我们完全没有必要用了vue就得吧项目做成单页的，我们可以使用一些他的特性，毕竟我觉得vue给我带来最大的好处就是组件化开发； Vue的优缺点？ 优点：简单：官方文档很清晰，比 Angular 简单易学。快速：异步批处理方式更新 DOM。组合：用解耦的、可复用的组件组合你的应用程序。紧凑：~18kb min+gzip，且无依赖。强大：表达式 &amp; 无需声明依赖的可推导属性 (computed properties)。对模块友好：可以通过 NPM、Bower 或 Duo 安装，不强迫你所有的代码都遵循 Angular 的各种规定，使用场景更加灵活。缺点：不兼容ie8，不过总体上觉得vue对我来说还是非常不错的，能看的懂文档，能上的去手，开发模式也比较好 指令keep-alive 指令keep-alive是做组件缓存的，就是把组件缓存起来不会销毁，下次打开这个组件直接显示出来，如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。一般用于有上啦加载的页面，因为如果一个页面有上啦加载的话，用户加载了好几页了都然后点击进入详情，在返回又得重新加载，这个体验很不好，有了keep-alive后就可以吧这个列表页面保存在内存中避免用户的重复操作，增强用户体验 Vuejs在变化检测问题 检测数组 由于javascript的限制，vuejs不能检测到下面数组的变化： 直接索引设置元素，如vm.item[0]={}; 修改数据的长度，如vm.item.length。 为了解决问题1，Vuejs扩展了观察数组，为它添加一个$set()方法： 与 example1.items[0] = ... 相同，但是能触发视图更新 example1.items.$set(0, { childMsg: &#39;Changed!&#39;}) 问题2，需要一个空数组替换items。 除了$set()，vuejs也为观察数组添加了$remove()方法，用于从目标数组中查找并删除元素，在内部调用了splice()。因此，不必： var index = this.items.indexOf(item) if (index !== -1) { this.items.splice(index, 1) } 只需：this.items.$remove(item); 检测对象 受ES5的显示，Vuejs不能检测到对象属性的添加或删除。因为Vuejs在初始化时候将属性转化为getter/setter，所以属性必须在data对象才能让Vuejs转换它，才能让它是响应的，例如： var data = { a: 1 } var vm = new Vue({ data: data }) vm.a 和 data.a 现在是响应的 vm.b = 2 vm.b 不是响应的 data.b = 2 data.b 不是响应的 不过，有办法在实例创建之后添加属性并且让它是响应的。对于Vue实例，可以使用$set(key,value)实例方法： vm.$set(&#39;b&#39;, 2) vm.b 和 data.b 现在是响应的 对于普通数据对象，可以使用全局方法Vue.set(object, key, value): Vue.set(data, &#39;c&#39;, 3)vm.c 和 data.c 现在是响应的 有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 添加属性。但是，添加到对象上的新属性不会触发更新。这时可以创建一个新的对象，包含原对象的属性和新的属性： 不使用 Object.assign(this.someObject, { a: 1, b: 2 })this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 }) key的使用 一般情况下，vue在渲染完成后，如果数据发生变化，只会重新渲染数据，不会重新渲染整个元素，但是有时候我们需要元素被重新渲染，此时就需要使用key关键字，使用v-bind绑定key关键字，可以实现在数据发生变化时候重新渲染整个元素。注：同一父级元素下所有子元素如果都要在数据变化后重新渲染元素，则需要被绑定的key $route和$router的区别 $route是路由信息对象，包含了path，params，query，hash，fullPath，matched，name这些路由信息参数,而$router是路由实例对象包含了路由的一些跳转方法，钩子函数等","path":"2019/01/10/Analysis/","date":"01-10","excerpt":"","preview":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1547098685032&di=30723d0fbb4a61e7e520474e8f897ad0&imgtype=0&src=http%3A%2F%2Fs9.sinaimg.cn%2Fmw690%2F0075pnsnzy7l5Z3djaEc8"},{"title":"Linux","text":"linux操作命令基础篇 进入目录 cd 目录名 显示当前路径 pwd 显示路径下的文件 ls ls -a 显示隐藏文件。隐藏文件以 . 开头命名 查看创建文本touch abc.txt 查看abc.txt 如果不存在则自动创建 创建文件夹mkdir 文件名 当前目录创建一个文件夹 mkdir -p name1/name2 当期目录递归创建name1/name2文件 重命名操作mv test test1 把test文件的名字修改为test1 mv test1 /home/wechat/ 将test1文件 移动到 /home/wechat 目录下 删除操作rm file 删除file文件(存在子文件时不可删除) rm -r /file 删除file文件下的所有目录文件 rm -rf ./ 删库跑路专用命令 复制cp file /home 复制file命令至home目录下 cp -r test /home/wechat 复制test文件夹和其所有子文件 至 /home/wechat目录下 cp -r test /home/wechat/test2 复制test文件夹和其所有子文件 至 /home/wechat目录下并重命名为test2 压缩、解压解压tartar xvf test.tar压缩tartar cvf test1.tar name 将name文件夹压缩为test1.tar 解压tar.gztar zxvf test.tar.gz 压缩tar zxvf test.tar.gz name 查找 &amp;&amp; 日志cat、more、less命令cat test.log 查看test.log 的文件内容cat -n test.log 查看test.log的文件内容并显示行号` more、less和cat作用基本相同，只不过more可以按页码来查看。都是按q退出查看 使用命令时，空格键翻页(显示下一屏内容) 回车显示下一行内容 find命令.代表当前目录find . -name &#39;*.txt&#39; 查找当前目录及其子目录下扩展名为txt的文件find . -mtime -2 列出两天内修改过的文件find . -atime -3 列出三天内被存取的文件find . -mmin +30 半个小时内被修改过的文件find . -amin +40 四十分钟内被存取过的文件find . -size +1M 查找当前目录超过1M的文件find . -size -1M 查找当前目录小于1M的文件find . -size +512k 超过512k的文件find . -empty 查找当前目录为空的文件或者文件夹 whereis命令whereis name/ 搜索name文件的路径 grep命令ps -ef|grep nginx 查看nginx的进程ps -ef|grep nginx -c 查看nginx的进程个数cat test.log | grep ^a 查找test.log 中以o开头的内容cat test.log | grep $k 查找test.log中以K结尾的内容cat test.log | grep &#39;bd4f63cc918611e8a14f7c04d0d7fdcc&#39; --color在test.log中搜索bd4f63cc918611e8a14f7c04d0d7fdcc并高亮等同于grep &#39;bd4f63cc918611e8a14f7c04d0d7fdcc&#39; test.log --color grep -n &#39;abc&#39; test.log 搜索结果显示行数 grep &#39;abc&#39; test1.log test2.log 从多个文件中查找abc tail命令tail -f xxx.log 查看xxx.log 默认显示最后10行tail -f 100 xx.log /tail -100f xx.log 查看100行 vim命令vimvim file 查看文本vim file1 file2 ... 查看多个文本正常模式/vim模式 通过ESC进行切换 vim模式下 i 在当前位置插入dd 删除光标所在行D :删除光标所在行2dd : 删除光标之后的2行G切换光标至末尾w! 强制写入wq 保存并退出q！ 强制退出 不保存/abc 在文本中查找abcset nu 显示文本行数k(上)、j(下)、h(左)、l(右) 移动光标yy 复制光标所在行p粘贴复制的o:另起一行 其他常用操作 who 查看用户信息 chmod 777 file 修改文件权限 每个人都可以对file文件进行读写和执行的权限 top 实时显示系统资源使用情况dh -h查看当前那磁盘使用情况du -sh /usr 计算usr文件大小 netstat –a 列出 tcp, udp 和 unix 协议下所有套接字的所有连接 kill 端口号 终止该端口kill -9 端口 立即强制终止端口rz lz 上传 和下载文件","path":"2018/12/26/linux/","date":"12-26","excerpt":"","preview":"https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1411074720,3182864252&fm=11&gp=0.jpg"},{"title":"Node","text":"Node是什么？Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node下载npm install 包名 –下载某包npm install 包名 -g(global) 进行全局安装包package,json 包管理文件npm root -g 查看npm全局路径npm uninstall 包名 卸载npm包 FS模块 写入文件——fs.writeFileSync(‘路径’,’写入内容’) 追加文件——fs.appendFileSync(‘路径’,’写入内容’) 写入数据——fs.writeFileSync(‘路径’,’写入数据’) 判断文件夹是否存在——fs.exists(文件/文件夹，function(exist){}) 查看文件信息——fs.stat(‘文件/文件夹’，function(err,st){err是报错信息,st是文件}) 判断是否为文件——fs.isFeile() 判断是否为文件夹——fs.Directory() 可续流——fs.ReadStam() 可写流——fs.writeStream(‘路径’,(需要写的文件)) 监听只读数据流——on(‘data’,function(chunk){监听只都数据流}) 读取结束事件——on(‘end’,function(){读取结束事件}) 可写流——writeStream(‘路径’,(要写文件)) 写入目标——ws.write(chunk) ws.end()(只触发一次) Path模块 path.normalize(路径) 格式化路径 path.extname(路径) 获取文件后缀名 path.dirname() 返回代表文件夹部分 path.resolve() 将一系列路径变为绝对路径 path.relative() 返回相对路径 path.format() 转为字符串 path.delimiter() 提供特定平台的路径分隔符 path.join(路径,[ext]) 连接路径 path.basename() 确定是否为绝对路径 path.isAbsolute() 确定是否为绝对路径 path.parse() 转换为路径 Buffer方法 Buffer.concat([buf1],[buf2]) 拼接buffer new Buffer/Buffer.from(‘’) 生成Buffer Http模块 request 请求体对象response 响应体对象 http.createServer(callback) 搭建服务器 response.writeHead(状态码,[opt]) 设置响应头信息 response.write(‘con’) 设置响应体内容 response.end() 结束响应(str/buffer) server.listen(port,[callback]) 监听端口号 request.url 请求路径request.method 请求方法content-Type 解析数据 转换方式 方法 转换对象 转换字符串 适用场景 path parse format 适用于磁盘路径 url parse format 操作地址栏 querystring parse stringify 操作地址栏(后半部分) json parse stringify 操作json数据 url.parse(url,true) 转换对象querystring.stringify(obj,[&amp;],[=]) 转换为字符串querystring.parse(str,[&amp;],[=]) 转换为对象","path":"2018/12/24/Node/","date":"12-24","excerpt":"","preview":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1545640493785&di=f5ceec7d34be80c6faa653123bb2a104&imgtype=0&src=http%3A%2F%2Fi1.hdslb.com%2Fvideo%2F66%2F664185a0fa37a4f855357e23d96bf52b.jpg"},{"title":"Git","text":"Git是什么？Git是目前世界上最先进的分布式版本控制系统（没有之一）。 Git的日常操作 克隆仓库：git clone git@github.com.git 拉取代码：git pull origin master 新建分支：git branch chenmanjie 删除分支：git branch -d chenmanjie 切换分支：git checkout chenmanjie 推送远程：git push origin master 查看提交记录：git log 回滚代码：git reset –hard [commit：6] 回滚文件：git checkout - filepath 回到最新代码：git reset HEAD git pull origin master 合并分支：git merge chenmanjie 会用PR给他人仓库贡献代码 linux日常操作 善用tab健，帮我们补全命令和路径 切换文件夹: cd 查看当前路径：pwd 查看当前文件夹下的文件： ls+ll 创建文件夹：mkdir 移动文件：mv 复制文件：cp 删除文件及文件夹：rm -rf(禁止使用) 编辑文件：vim 查看历史命令：history","path":"2018/12/21/Git/","date":"12-21","excerpt":"","preview":"https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2659714922,1287356256&fm=26&gp=0.jpg"},{"title":"Promise","text":"Promise 是异步编程的一种解决方案: 从语法上讲，promise是一个对象，从它可以获取异步操作的消息。有三种状态:pending(等待态)，fulfiled(成功态)，rejected(失败态)；状态一旦改变，就不会再变。创造promise实例后，它会立即执行。promise是用来解决两个问题的: 回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象 promise可以支持多个并发的请求，获取并发请求中的数据 这个promise可以解决异步的问题，本身不能说promise是异步的 Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。 Promise的构造函数接收一个参数:函数，并且这个函数需要传入两个参数: resolve :异步操作执行成功后的回调函数 reject:异步操作执行失败后的回调函数 reject的用法: 把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。 all的用法: 谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象 then 链式操作的用法123456789promise.then((data) =&gt; &#123; console.log(data);&#125;).then((data) =&gt; &#123; console.log(data);&#125;).then((data) =&gt; &#123; console.log(data);&#125;); 方法总结: 捕获错误的方法 catch() 解析全部方法 all() 竞赛 race() 生成一个成功的promise resolve() 生成一个失败的promise reject()","path":"2018/12/20/Promise/","date":"12-20","excerpt":"","preview":"https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=381607956,4179025564&fm=26&gp=0.jpg"},{"title":"Vue.js快速入门","text":"Vue.js介绍Vue.js是当下很火的一个JavaScript MVVM库，它是以数据驱动和组件化的思想构建的。相比于Angular.js，Vue.js提供了更加简洁、更易于理解的API，使得我们能够快速地上手并使用Vue.js。 Vue.js的常用指令Vue.js的指令是以v-开头的，它们作用于HTML元素，指令提供了一些特殊的特性，将指令绑定在元素上时，指令会为绑定的目标元素添加一些特殊的行为，我们可以将指令看作特殊的HTML特性（attribute）。内置指令： v-if指令 v-show指令 v-else指令 v-for指令 v-bind指令 v-on指令Vue.js具有良好的扩展性，也可以开发一些自定义的指令 v-if是条件渲染指令，它根据表达式的真假来删除和插入元素，它的基本语法如下：v-if=&quot;expression&quot; expression是一个返回bool值的表达式，表达式可以是一个bool属性，也可以是一个返回bool的运算式。 注意：v-if指令是根据条件表达式的值来执行元素的插入或者删除行为。 v-else指令可以用v-else指令为v-if或v-show添加一个“else块”。v-else元素必须立即跟在v-if或v-show元素的后面——否则它不能被识别。v-show指令v-show也是条件渲染指令，和v-if指令不同的是，使用v-show指令的元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性。v-for指令v-for指令基于一个数组渲染一个列表，它和JavaScript的遍历语法相似：v-for=&quot;item in items&quot; items是一个数组，item是当前被遍历的数组元素。v-bind指令v-bind指令可以在其名称后面带一个参数，中间放一个冒号隔开，这个参数通常是HTML元素的特性。 vue+webpack安装,生成初始化vue项目安装vue-cli npm install -g vue-cli 全局安装vue-cli vue init webpack projectName 生成项目名为projectName的模板，这里的项目名projectName是项目名称 cd projectName 进入项目文件 npm install 初始化安装依赖 初始化依赖完成后，命令运行：npm run dev 上述完成后，我们就完成vue的项目就已经生产完成，当我们运行 localhost:8080 就能看见如下图的vue官方logo：","path":"2018/12/19/VueJs/","date":"12-19","excerpt":"","preview":"http://img.mp.itc.cn/upload/20161008/e8fadf087de643e8862d2836d0a65bba_th.png"},{"title":"Markdown语法格式","text":"标题 一级标题二级标题三级标题列表 列表1 列表2 列表1 列表2 列表1 列表2 列表1 列表2 引用区域 这里为引用区域部分 引用区域2 引用区域3 分割线 链接跳转百度跳转腾讯 图片 代码&lt;h4&gt;这里是代码&lt;/h4&gt;123&lt;h2&gt;我是代码段1&lt;/h2&gt;&lt;div&gt;我是代码段2&lt;/div&gt;&lt;span&gt;我是代码段3&lt;/span&gt; { 这里也是代码} 强调语句文字倾斜文字倾斜文字加粗文字加粗 删除已删除的文字 表格 name age sex jason 25 man rous 21 woman 这里是表头1 这里是表头2 这里是内容1 这里是内容2 学号 姓名 分数 01 小明 60 02 小红 70 03 小王 80","path":"2018/12/18/MarkDown/","date":"12-18","excerpt":"","preview":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1545231731249&di=13ef20b593507dfc5fa857ce56317d04&imgtype=0&src=http%3A%2F%2Fwww.cnplugins.com%2Fuploads%2Fcrximage%2F201801%2Fmarkdown%25E9%2598%2585%25E8%25AF%25BB%25E5%2599%25A8-logo-0.0.2.jpg"}]}